<HTML>
<HEAD>
<TITLE>Text::Merge - v.0.29  General purpose text/data merging methods in Perl.</TITLE>
<LINK REV="made" HREF="mailto:root@porky.devel.redhat.com">
</HEAD>

<BODY>

<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#NAME">NAME</A>
	<LI><A HREF="#SYNOPSIS">SYNOPSIS</A>
	<LI><A HREF="#DESCRIPTION">DESCRIPTION</A>
	<UL>

		<LI><A HREF="#Technical_Details">Technical Details</A>
		<LI><A HREF="#Markup_Tags">Markup Tags</A>
		<LI><A HREF="#Item_Support">Item Support</A>
		<LI><A HREF="#Line_by_Line_Mode">Line by Line Mode</A>
		<LI><A HREF="#Templates">Templates</A>
		<LI><A HREF="#Methods">Methods</A>
	</UL>

	<LI><A HREF="#PREREQUISITES">PREREQUISITES</A>
	<LI><A HREF="#AUTHOR">AUTHOR</A>
</UL>
<!-- INDEX END -->

<HR>
<P>
<H1><A NAME="NAME">NAME</A></H1>
<P>
Text::Merge - v.0.29 General purpose text/data merging methods in Perl. 

<P>
<HR>
<H1><A NAME="SYNOPSIS">SYNOPSIS</A></H1>
<P>
<PRE>        $merge = new Text::Merge;
</PRE>
<P>
<PRE>        $merge-&gt;line_by_line();         # query
        $merge-&gt;line_by_line(0);        # turn off
        $merge-&gt;line_by_line(1);        # turn on
</PRE>
<P>
<PRE>        $merge-&gt;set_delimiters('&lt;&lt;', '&gt;&gt;');  # user defined delims
</PRE>
<P>
<PRE>        $success = $merge-&gt;publish($template, \%data);
        $success = $merge-&gt;publish($template, \%data, \%actions);
        $success = $merge-&gt;publish($template, $item);
</PRE>
<P>
<PRE>        $success = $merge-&gt;publish_to($handle, $template, \%data);
        $success = $merge-&gt;publish_to($handle, $template, \%data, \%actions);
        $success = $merge-&gt;publish_to($handle, $template, $item);
</PRE>
<P>
<PRE>        $text = $merge-&gt;publish_text($template, \%data);
        $text = $merge-&gt;publish_text($template, \%data, \%actions);
        $text = $merge-&gt;publish_text($template, $item);
</PRE>
<P>
<PRE>        $success = $merge-&gt;publish_email($mailer, $headers, $template, \%data);
        $success = $merge-&gt;publish_email($mailer, $headers, $template, 
                                                             \%data, \%actions);
        $success = $merge-&gt;publish_email($mailer, $headers, $template, $item);
</PRE>
<P>
<HR>
<H1><A NAME="DESCRIPTION">DESCRIPTION</A></H1>
<P>
The <CODE>Text::Merge</CODE> package is designed to provide a quick, versatile, and extensible way to
combine presentation templates and data structures. The <CODE>Text::Merge</CODE> package attempts to do this by assuming that templates are constructed with
text and that objects consist of data and functions that operate on that
data.  <CODE>Text::Merge</CODE> 
is very simple, in that it works on one file and one object at a time,
although an extension exists to display lists (<CODE>Text::Merge::Lists</CODE>) and <CODE>Text::Merge</CODE> itself could easily be extended further.  

<P>
This is not XML and is intended merely to ``flatten'' the learning curve
for non-programmers who design display pages for programmers or to provide
programmers with a quick way of merging page templates with data sets or
objects without extensive research.

<P>
The templates can be interpreted ``line by line'' or taken as a whole.

<P>
<HR>
<H2><A NAME="Technical_Details">Technical Details</A></H2>
<P>
This object is normally inherited and so the <CODE>new()</CODE> function is
the constructor. It just blesses an anonymous HASH reference, sets two
flags within that HASH, and returns it. I'm am acutely aware of the
criticisms of the overuse of OOP (Object Oriented Programming). This module
needs to be OO because of its extensibility and encapsulation; I wanted to
impose classification of the objects to allow the greatest flexibility in
context of implementation.  <CODE>Text::Merge</CODE> is generally used on web servers, and can become integrated quickly into
the httpd using mod_perl, hence the encapsulation and inheritance provided
by the Perl OO model clearly outweighed the constraints thereby imposed.
That's my excuse...what's yours?

<P>
There are four public methods for the <CODE>Text::Merge</CODE> object: <A HREF="#item_publish">publish()</A>, <A HREF="#item_publish_to">publish_to()</A>, <A HREF="#item_publish_text">publish_text()</A>, 
<A HREF="#item_publish_email">publish_email()</A>. The first, <A HREF="#item_publish">publish()</A>, sends output to the currently selected file handle (normally STDOUT). The
second method, <A HREF="#item_publish_text">publish_text()</A>, returns the merged output as a text block. The last method, 
<A HREF="#item_publish_email">publish_email()</A>, sends the merged output as a formatted e-mail message to the designated
mailer.

<P>
Support is provided to merge the data and the functions performed on that
data with a text template that contains substitution tag markup used to
designate the action or data conversion. Data is stored in a HASH that is
passed by reference to the publishing methods. The keys of the data hash
correspond to the field names of the data, and they are associated with
their respective values. Actions (methods) are similarly referenced in a
hash, keyed by the action name used in the template.

<P>
Here is a good example of a publishing call in Perl:

<P>
<PRE>        $obj = new Text::Merge;
        %data = ( 'Name'=&gt;'John Smith', 'Age'=&gt;31, 'Sex'=&gt;'not enough' );
        %actions = ( 'Mock' =&gt; \&amp;mock_person,  'Laud' =&gt; \&amp;laud_person );
        $obj-&gt;publish($template, \%data, \%actions);
</PRE>
<P>
In this example, <CODE>mock_person()</CODE> and <CODE>laud_person()</CODE> would be subroutines that took a single hash reference, the data set, as an
argument. In this way you can create dynamic or complex composite
components and reference them with a single tag in the template. The
actions HASH has been found to be useful for default constructs that can be
difficult to code manually, giving page designers an option to work with
quickly.

<P>
<HR>
<H2><A NAME="Markup_Tags">Markup Tags</A></H2>
<P>
Simply put, tags are replaced with what they designate. A tag generally
consists of a prefix, followed by a colon, then either an action name or a
field name followed by zero or more formatting directives seperated by
colons. In addition, blocks of output can be contained within curly
brackets in certain contexts for conditional display.

<DL>
<DT><STRONG><A NAME="item_REF">REF: tags</A></STRONG><DD>
<P>
Simple data substitution is achieved with the <A HREF="#item_REF_">REF:</A> tag. Here is an example of the use of a <A HREF="#item_REF_">REF:</A> tag in context, assume we have a key-value pair in our data HASH
associating the key 'Animal' with the value of 'turtle':

<P>
<PRE>        The quick brown REF:Animal jumped over the lazy dog.
</PRE>
<P>
when filtered, becomes:

<P>
<PRE>        The quick brown turtle jumped over the lazy dog.
</PRE>
<P>
The <A HREF="#item_REF_">REF:</A> tag designators may also contain one or more format directives. These are
chained left to right, and act to convert the data before it is displayed.
For example:

<P>
<PRE>        REF:Animal:lower:trunc3
</PRE>
<P>
would result in the first three letters of the SCALAR data value associated
with Animal in lower case. See the section, <CODE>Data Conversions Formats</CODE>, for a list of the available SCALAR data formatting directives. Note that
some conversions may be incompatible or contradictory. The system will not
necessarily warn you of such cases, so be forewarned.

<P>
Any <A HREF="#item_REF_">REF:</A> tag designator can be surrounded by curly brace pairs containing text that
would be included in the merged response only if the result of the
designator is not empty (has a length). There must be no spaces between the
tag and the curly braced text. If line-by-line mode is turned off, then the
conditional text block may span multiple lines. For example:

<P>
<PRE>        The {quick brown }REF:Animal{ jumps over where the }lazy dog lies.
</PRE>
<P>
Might result in:

<P>
<PRE>        The quick brown fox jumps over where the lazy dog lies.
</PRE>
<P>
or, if the value associated with the data key 'Animal' was undefined,
empty, or zero:

<P>
<PRE>        The lazy dog lies.
</PRE>
<DT><STRONG><A NAME="item_IF">IF: tags</A></STRONG><DD>
<P>
The <A HREF="#item_IF_">IF:</A> tag designators performs a conditional display. The syntax is as follows:

<P>
<PRE>        IF:FieldName:formats{Text to display}
</PRE>
<P>
This designator would result in the string <STRONG>Text to display</STRONG> being returned if the formatted data value is not empty. The curly braced
portion is required, and no curly braces are allowed before the designator.

<DT><STRONG><A NAME="item_NEG">NEG: tags</A></STRONG><DD>
<P>
The <A HREF="#item_NEG_">NEG:</A> tag designator is similar to the <A HREF="#item_IF_">IF:</A> tag, but the bracketed text is processed only if the formatted data value
is empty (zero length) or zero. Effectively the <A HREF="#item_NEG_">NEG:</A> can be thought of as <STRONG>if not</STRONG>. Here is an example:

<P>
<PRE>        NEG:FieldName:formats{Text to display if the result is empty.}
</PRE>
<DT><STRONG><A NAME="item_ACT">ACT: tags</A></STRONG><DD>
<P>
The <A HREF="#item_ACT_">ACT:</A> tag designates that an action is to be performed (a subroutine call) to
obtain the result for substition. The key name specified in the designator
is used to look up the reference to the appropriate subroutine, and the
data HASH reference is passed as the sole argument to that subroutine. The
returned value is the value used for the substition.

<P>
<A HREF="#item_ACT_">ACT:</A> is intended to be used to insert programmatic components into the document.
It can only specify action key names and has no equivalent tags to <A HREF="#item_IF_">IF:</A> and <A HREF="#item_NEG_">NEG:</A>. The curly brace rules for the <A HREF="#item_ACT_">ACT:</A>
tag are exactly the same as those for the <A HREF="#item_REF_">REF:</A> tag.

<DT><STRONG><A NAME="item_Conditional">Conditional Text Braces</A></STRONG><DD>
<P>
All tags support conditional text surrounded by curly braces. If the <A HREF="#item_line_by_line">line_by_line()</A> switch is set, then the entire tag degignator must be on a single line of
text, but if the switch is OFF (default) then the conditional text can span
multiple lines.  

<P>
The two conditional tags, <A HREF="#item_IF_">IF:</A> and <A HREF="#item_NEG_">NEG:</A>, require a single conditional text block, surrounded by curly braces,
immediately following (suffixing) the field name or format string. For
example:

<P>
<PRE>        IF:SomeField{this text will print}
</PRE>
<P>
The <A HREF="#item_REF_">REF:</A> and <A HREF="#item_ACT_">ACT:</A> tags allow for curly braces both at the beginning (prefixing) and at the
end (suffixing). For example:

<P>
<PRE>        {Some optional text }REF:SomeValue{ more text.}
</PRE>
<DT><STRONG><A NAME="item_Command">Command Braces</A></STRONG><DD>
<P>
You may bracket entire constructs (along with any conditional text) with
double square brackets to set them off from the rest of the document. The
square brackets would be removed during substitution:

<P>
<PRE>        The [[IF:VerboseVar{quick, brown }]]fox jumped over the lazy dog.
</PRE>
<P>
assuming that 'VerboseVar' represented some data value, the above example
would result in one of:

<P>
<PRE>        The quick, brown fox jumped over the lazy dog.
or
        The fox jumped over the lazy dog.
</PRE>
<DT><STRONG><A NAME="item_Data">Data Conversion Formats</A></STRONG><DD>
<P>
Here is a list of the data conversion format and the a summary. Details are
undetermined in some cases for exceptions, but all of the conversion to
some satisfactory degree. These conversion methods will treat all values as
SCALAR values:

<P>
<PRE>        upper   -  converts all lowercase letters to uppercase
        lower   -  converts all uppercase letters to lower
        proper  -  treats the string as a Proper Noun 
        trunc## -  truncate the scalar to ## characters (## is an integer)
        words## -  reduce to ## words seperated by spaces (## is an integer)
        paragraph## -  converts to a paragraph ## columns wide
        indent## - indents plain text ## spaces
        int     -  converts the value to an integer
        float   -  converts the value to a floating point value
        string  -  converts the numeric value to a string (does nothing)
        html    -  replaces newlines with HTML B&lt;BR&gt; tags
        dollars -  converts the value to 2 decimal places
        percent -  converts the value to a percentage
        abbr    -  converts a time value to m/d/yy format
        short   -  converts a time value to m/d/yy H:MMpm format
        time    -  converts a time value to H:MMpm (localtime am/pm)
        24h     -  converts a time value to 24hour format (localtime)
        dateonly - converts a time value to Jan. 1, 1999 format
        date    - same as 'dateonly' with 'time'
        ext     -  converts a time value to extended format:
                        Monday, Januay 12th, 1999 at 12:20pm
        unix    -  converts a time value to UNIX date string format
        escape  -  performs a browser escape on the value (&amp;#123;)
        unescape - performs a browser unescape (numeric only)
        urlencode - performs a url encoding on the value (%3B)
        urldecode - performs a url decoding (reverse of urlencode)
</PRE>
<P>
Most of the values are self explanitory, however a few may need
explanation: The <CODE>trunc</CODE> format must be suffixed with an integer digit to define at most how many
characters should be displayed, as in <CODE>trunc14</CODE>.

<P>
The <CODE>html</CODE> format just inserts a &lt;BR&gt; construct at every newline in the string.
This allows text to be displayed appropriately in some cases.

<P>
The <CODE>escape</CODE> format performs an HTML escape on all of the reserved characters of the
string. This allows values to be displayed correctly on browsers in most
cases. If your data is not prefiltered, it is usually a good idea to use <STRONG>escape</STRONG> on strings where HTML formatting is prohibited. For example a '$' value
would be converted to '&amp;#36;'.

<P>
The <CODE>unescape</CODE> format does the reverse of an <CODE>escape</CODE> format, however it does not operate on HTML mnemonic escapes, allowing
special characters to remain intact. This can be used to reverse escapes
inherent in the use of other packages.

<P>
The <CODE>urlencode</CODE> and <CODE>urldecode</CODE> formats either convert a value (text string) to url encoded format,
converting special characters to their <CODE>%xx</CODE> equivalent, or
converting to the original code by decoding <CODE>%xx</CODE> characters
respectively from the url encoded value.

</DL>
<P>
<HR>
<H2><A NAME="Item_Support">Item Support</A></H2>
<P>
The publishing methods all require at the very least a template, a data
set, and the action set; although either the data set or the action set or
both could be empty or null. You may also <STRONG>bundle</STRONG> this information into a single HASH (suitable for blessing as a class) with
the key 'Data' associated with the data HASH reference, and the key
'Actions' associated with the action HASH reference. A restatement of a
previous example might look like this:

<P>
<PRE>        $obj = new Text::Merge;
        $data = { 'Name'=&gt;'John Smith', 'Age'=&gt;31, 'Sex'=&gt;'not enough' };
        $actions = { 'Mock' =&gt; \&amp;mock_person,  'Laud' =&gt; \&amp;laud_person };
        $item = { 'Data' =&gt; $data,  'Actions' =&gt; $actions };
        $obj-&gt;publish($template, $item);
</PRE>
<P>
In addition, if you specify a key 'ItemType' in your <CODE>$item</CODE> and give it a value, then the item reference will be handed to any methods
invoked by the <A HREF="#item_ACT_">ACT:</A> tags, rather than just the data hash. This allows you to construct <STRONG>items</STRONG> that can be merged with templates. For example, the following code is
valid:

<P>
<PRE>        %data = ( 'Author' =&gt; 'various',  'Title' =&gt; 'The Holy Bible' );
        %actions = ( 'Highlight' =&gt; \&amp;highlight_item );
        $item = { 'ItemType'=&gt;'book', 'Data'=&gt;\%data, 'Actions'=&gt;\%actions };
        bless $item, Some::Example::Class;
        $obj-&gt;publish($template, $item);
</PRE>
<P>
In this last example, the designator <CODE>ACT:Highlight</CODE> would result in the object <CODE>$item</CODE> being passed as the only argument to the subroutine <CODE>highlight_item()</CODE> referenced in the action HASH.

<P>
<HR>
<H2><A NAME="Line_by_Line_Mode">Line by Line Mode</A></H2>
<P>
By default, the publishing methods slurp in the entire template and process
it as a text block. This allows for multi-line conditional text blocks.
However, in some cases the resulting output may be very large, or you may
want the output to be generated line by line for some other reason (such as
unbuffered output). This is accomplished through the <A HREF="#item_line_by_line">line_by_line()</A> method, which accepts an optional boolean value, which sets the current
setting if specified or returns the current settingif not. Note that this
has the most notable impact on the <A HREF="#item_publish">publish()</A> and <A HREF="#item_publish_email">publish_email()</A> methods, since the results of the merge operations are sent to a handle. If
the line by line switch is set, then the <A HREF="#item_publish_text">publish_text()</A> method will substitute line by line, but will still return the entire
merged document as a single text block (not line by line). 

<P>
This is turned OFF by default.

<P>
<HR>
<H2><A NAME="Templates">Templates</A></H2>
<P>
Templates consist of text documents that contain special substitution
designators as described previously. The template arguments passed to the
publishing functions can take one of three forms:

<DL>
<DT><STRONG><A NAME="item_File">File Handle</A></STRONG><DD>
<P>
This is a FileHandle object not a glob. You must use the <CODE>FileHandle</CODE> package that comes with the Perl distribution for this type of template
argument. Processing begins at the current file position and continues
until the end of file condition is reached.

<DT><STRONG>File Path</STRONG><DD>
<P>
If the argument is a scalar string with no whitespace, it is assumed to be
a file path. The template at that location will be used when merging the
document.

<DT><STRONG><A NAME="item_Text">Text Block</A></STRONG><DD>
<P>
If the argument is a scalar string that contains whitespace, it is assumed
to be the actual text template. Substitution will be performed on a locally
scoped copy of this argument.  

<P>
Note that you should not use this type of template argument if your
template is very large and you are using line by line mode. In this case
you should use a FileHandle or file path argument.

</DL>
<P>
<HR>
<H2><A NAME="Methods">Methods</A></H2>
<DL>
<DT><STRONG><A NAME="item_new">new()</A></STRONG><DD>
<P>
This method gives us a blessed hash reference, with the following attribute
keys:

<P>
<PRE>        _Text_Merge_LineMode
</PRE>
<P>
Other keys can be added by objects which inherit <CODE>Text::Merge</CODE>.

<DT><STRONG><A NAME="item_line_by_line">line_by_line($setting)</A></STRONG><DD>
<P>
This method returns the current setting if the <CODE>$setting</CODE> argument is omitted. Otherwise it resets the line-by-line mode to the
setting requested. A non-zero value tells the publishing methods to process
the template line by line. For those methods that output results to a
handle, then those results will also be echoed line by line.

<DT><STRONG><A NAME="item_set_delimiters">set_delimiters($start, $end)</A></STRONG><DD>
<P>
This method assigns a new command delimiter set for the tags. The 'colon'
character is not allowed within the delimiter, and the delimiter may not be
a single curly bracket. Both delimiters must be provided, and they cannot
be identical.

<DT><STRONG><A NAME="item_publish">publish($template, $dataref, $actionref)</A></STRONG><DD>
<P>
This is the normal publishing method. It merges the specified template with
the data and any provided actions. The output is sent to the currently
selected handle, normally STDOUT.

<DT><STRONG><A NAME="item_publish_to">publish_to($handle, $template, $dataref, $actionref)</A></STRONG><DD>
<P>
This is similar to the normal publishing method. It merges the specified
template with the data and any provided actions. The output is sent to the
specified <CODE>$handle</CODE> or to the currently selected handle, normally STDOUT, if the <CODE>$handle</CODE> argument is omitted.

<DT><STRONG><A NAME="item_publish_text">publish_text($template, $dataref, $actionref)</A></STRONG><DD>
<P>
This method works similar to the <A HREF="#item_publish_to">publish_to()</A> method, except it returns the filtered output as text rather than sending
it to the currently selected filehandle.

<DT><STRONG><A NAME="item_publish_email">publish_email($mailer, $headers, $filepath, $data, $actions)</A></STRONG><DD>
<P>
This method is similar to <A HREF="#item_publish">publish()</A> but opens a handle to <CODE>$mailer</CODE>, and sending the merged data formatted as an e-mail message.  <CODE>$mailer</CODE> may contain the sequences <CODE>RECIPIENT</CODE> and/or <CODE>SUBJECT</CODE>. If either does not exists, it will be echoed at the beginning of the
email (in the form of a header), allowing e-mail to be passed preformatted.
This is the preferred method; use a mailer that can be told to accept the
``To:'', ``Subject:'' and ``Reply-To:'' fields within the body of the
passed message and do not specify the <CODE>RECIPIENT</CODE> or <CODE>SUBJECT</CODE> tags in the <CODE>$mailer</CODE> string. Returns false if failed, true if succeeded. The recommended mail
program is 'sendmail'.  <CODE>$headers</CODE> is a HASH reference, containing the header information. Only the following
header keys are recognized:

<P>
<PRE>        To
        Subject
        Reply-To
        CC
        From (works for privileged users only)
</PRE>
<P>
The values associated with these keys will be used to construct the desired
e-mail message header. Secure minded site administrators might put hooks in
here, or even better clean the data, to protect access to the system as a
precaution, to avoid accidental mistakes perhaps.

<P>
Note: the <CODE>$mailer</CODE> argument string should begin with the type of pipe required for your
request. For sendmail, this argument would look something like (note the
vertical pipe):

<P>
<PRE>        '|/usr/bin/sendmail -t'
</PRE>
<P>
Be careful not to run this with write permission on the sendmail file and
forget the process pipe!!!

</DL>
<P>
<HR>
<H1><A NAME="PREREQUISITES">PREREQUISITES</A></H1>
<P>
This module was written and tested entirely in Perl 5.004 and runs with <CODE>-Tw</CODE> set and <CODE>use strict</CODE>. It requires use of the package <CODE>FileHandle</CODE> which is part of the standard perl distribution.

<P>
<HR>
<H1><A NAME="AUTHOR">AUTHOR</A></H1>
<P>
This software is released under the Perl Artistic License. Derive what you
wish, as you wish, but please attribute releases and include derived source
code. (C) 1997, 1998 by Steven D. Harris, <A
HREF="mailto:perl@nullspace.com">perl@nullspace.com</A>

</BODY>

</HTML>
